<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Нотация описания архитектуры приложения</title>
  </head>
  <body>
    <h1>Нотация описания архитектуры приложения</h1>
    <h2>Мотивация</h2>
    <p>
      Я, как <span style="color: red;">технический директор</span>, регулярно сталкиваюсь с
      необходимостью обсудить с командой архитектуру нового приложения или
      микросервиса. И в рамках таких обсуждений я понял, что не существует
      единого подхода, который позволил бы эффективно общаться команде, обсуждая
      архитектурные решения.
    </p>
    <p>
      Понятно, что на словах это не объяснишь и приходится прибегать к
      дополнительным инструментам в виде доски и маркера или же при текущих
      реалиях - online доски типа
      <a href="https://miro.com/ru" target="_blank">Miro</a>. Но даже в этом
      случае обсуждение сваливается в хаотично нарисованные квадратики, круги
      или прямоугольники с текстом, как-то соединённые стрелками.
    </p>
    <p>
      При этом от обсуждения к обсуждению одна и так же схема может быть
      нарисована 1000 разными способами. Кто-то в творческом порыве начинает
      рисовать иконки пользователей или серверов, а кто-то рисует поток из 10
      стрелок, чтобы показать все возможные варианты взаимодействия. И это - не
      эффективная коммуникация, где одно и тоже можно понять по-разному при этом
      потратив какое-то время на пояснение чем шестиугольник отличается круга.
    </p>
    <h2>А что есть?</h2>
    <p>
      Осознав проблемы я первым делом начал искать готовые варианты. Вот
      несколько из них:
    </p>
    <ul>
      <li>
        Диаграмма классов - иногда бывает удобной для анализа уже существующего
        кода, но не применима для изначального проектирования, где мы оперируем
        более верхне уровневыми объектами.
      </li>
      <li>
        c4model - уже ближе к теме и предлагает 4 уровня детализации схемы
        программного обеспечения. Но часто из всех 4-х уровней подходит 3-й,
        когда мы планируем новый сервис, а на 3-м уровне стандартов описания
        немного. Отлично подходит для верхнего уровня описания системы, но при
        детализации на компоненты не имеет детальных стандартов.
      </li>
    </ul>
    <p>
      Потому после нескольких экспериментов, я решил подготовить простую
      нотацию, которая позволит описать архитектуру приложений на том уровне,
      чтобы мы могли:
    </p>
    <ul>
      <li>Разбить создание его на задачи.</li>
      <li>
        Проверить корректность деления на модули, чтобы сократить их
        связанность.
      </li>
      <li>
        Упростить коммуникацию в команде при обсуждении деталей проектирования
        приложения.
      </li>
      <li>
        Использовать её для документирования архитектуры как монолита, так и
        микросервисов.
      </li>
    </ul>
    <h2>Требования к нотации</h2>
    <p>
      Перед тем, как переходить к описанию предлагаемой нотации следует
      сформулировать требования, которым она должна удовлетворять:
    </p>
    <ul>
      <li>
        Она должна на верхнем уровне описывать отделимые части системы, которые
        далее я буду назвать «компоненты».
      </li>
      <li>
        Связи между ними должны описать зависимости и поток вызовов, но не быть
        слишком усложнены. По связям должно быть сразу понятно наличии
        архитектурных ошибок.
      </li>
      <li>
        Схема должна подходить как для описания монолитного приложения, так и
        микросервисной архитектору.
      </li>
      <li>
        Фокус должен быть на описании нашей архитектуры, максимально
        абстрагировавшись от внешних систем.
      </li>
    </ul>
    <p>
      Ниже будет написано мое видение такой нотации с учётом опыта тестирования
      её вместе с командой. На практике она позволила в кратчайшие сроки
      обсуждать изменения в архитектуре или планировать полноценные новые
      сервисы или приложения.
    </p>
    <h2>Структура диаграммы</h2>
    <p>
      В первую очередь давайте перечислим все возможные блоки, которые могут
      использоваться в диаграмме:
    </p>
    <ul>
      <li>
        Приложения - отделимые приложения для описания микросервисного подхода.
      </li>
      <li>Модули - объединяют компоненты.</li>
      <li>Компоненты - основные строительные блоки приложения.</li>
      <li>
        Внутренние связи между компонентами - обозначение связей между
        компонентами.
      </li>
      <li>Внешние связи - с другими системами или между микросервисами.</li>
      <li>Передаваемые объекты - между компонентами системы или вне</li>
      <li>
        Детализация полей, которые могут быть детальным описанием свойств,
        методов и структуры данных.
      </li>
    </ul>
    <h2>Компоненты</h2>
    <p>
      Стоит начать рассмотрение именно с компонент, так как они являются
      строительными блоками всей нашей диаграммы. Это изолированный с точки
      зрения логики кусок кода, который может в реальности представлять собой
      класс или отдельный файл.
    </p>
    <p>Это может быть:</p>
    <ul>
      <li>Контроллер, которые обрабатывает входящие запросы.</li>
      <li>Сервис, отвечающий за бизнес логику работы с платежами.</li>
      <li>Репозиторий, взаимодействующий с базой данных.</li>
      <li>Обработчик event событий при использовании event sourcing.</li>
      <li>
        Бизнес entity пользователя, содержащие поля для него и методы работы.
      </li>
    </ul>
    <p>
      Фактически все, что вы можете выделить в виде класса с инкапсулированной
      логикой - это компонент.
    </p>
    <p>
      Для того чтобы максимально полно описать компонент можно указать следующие
      параметры:
    </p>
    <ul>
      <li>
        Имя - название компонента, отражающие его суть или даже название класса
      </li>
      <li>Тип - чтобы понять что это контроллер или репозиторий</li>
      <li>Пояснение - если требуется дополнительное описание.</li>
    </ul>
    <p>Примеры:</p>
    <img src="./images/image1.jpg" alt="image1" />
    <br />
    <h2>Внутренние связи</h2>
    <p>
      Неразрывной стрелкой показываются связи между компонентами системы. При
      этом, направление стрелки указывает направление зависимости (вызова
      методов). Если комплект UserContoller требует вызова метода из
      UserService:
    </p>
    <p>
      При этом связь не указывает поток передачи данных, чтобы не усложнять
      диаграмму.
    </p>
    <p>
      Двунаправленный стрелки возможны, но это будут обозначать круговую
      зависимость, которую следует избегать.
    </p>
    <p>
      На стрелке можно дополнительно указать название метода, который будет
      вызываться, если это важно:
    </p>
    <img src="./images/image2.jpg" alt="image2" />
    <br />
    <h2>Внешние связи</h2>
    <p>
      Пунктирной стрелкой обозначится входящее или исходящее сообщение, или
      событие в / из внешней системой. Это может быть API вызов, сообщения через
      шину RMQ в другие части системы, запрос в базу данных или интеграция с
      внешним API.
    </p>
    <p>В описании можно дать:</p>
    <ul>
      <li>Название команды</li>
      <li>Тип запроса</li>
      <li>Название внешнего сервиса.</li>
    </ul>
    <p>Примеры:</p>
    <img src="./images/image3.jpg" alt="image3" />
    <br />
  </body>
</html>
